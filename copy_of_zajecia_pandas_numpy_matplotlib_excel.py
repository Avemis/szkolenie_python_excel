# -*- coding: utf-8 -*-
"""Copy of Zajecia_pandas_numpy_matplotlib_excel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cF7f8628dI6KRLtFHX0OaiNBvcxgKLFZ

# NumPy, pandas i Matplotlib

## NumPy
"""

import numpy as np

# tablica 1-wymiarowa (wektor)

vec = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
vec2 = [1, 2, 3, 4, 5]
np_vec = np.array(vec2)
print("WEKTOR")
print(vec)
print("Liczba wymiarów: ", vec.ndim)
print("Wymiar: ", vec.shape)
print("Rozmiar: ", vec.size)
print("Typ tablicy: ", vec.dtype)

# tablica 2-wymiarowa (macierz)

mat = np.array([[1,2],[3,4],[5,6],[7,8]])
mat2 = np.matrix([[1,0,1],[0, 0, 0],[1, 0, 1]])
print("Macierz 2D")
print(mat)
print(mat2)
print("Liczba wymiarów: ", mat.ndim)
print("Wymiar: ", mat.shape)
print("Rozmiar: ", mat.size)
print("Typ tablicy: ", mat.dtype)

# macierz wielowymiarowa z krotek
print("Macierz z krotek")
tupMat = np.array([(1,'a',3.0),(2,'b',3.5)])
print(tupMat)
print("Liczba wymiarów: ", tupMat.ndim)
print("Wymiar: ", tupMat.shape)
print("Rozmiar: ", tupMat.size)
print("Typ tablicy: ", tupMat.dtype)

print(np.random.rand(5))          # wektor 5 wartości losowych w zakresie od 0 do 1
print(np.random.randn(5))         # wektor 5 wartości losowych z o rozkładzie Gaussa
print(np.arange(-10,10,2))        # działa jak range, tylko zwraca ndarray zamiast list
print(np.arange(12).reshape(3,4)) # zmiana wymiarów macierzy
print(np.arange(12).reshape(4,3))
print(np.linspace(0,1,10))        # wektor 10 wartości od 0 do 1 (równa odległość między punktami)
print(np.logspace(-3,3,7))        # wektor 7 wartości od 10^-3 do 10^3 (odległości logarytmiczne)

print(np.zeros((10,10)))      # macierz zer
print(np.ones((3,2)))         # macierz jedynek
print(np.eye(5))              # macierz jednostkowa

x = np.array([1,2,3,4,5])

print(x + 1)      # dodanie do każdego elementu wektora/macierzy 1
print(x - 1)      # odjęcie od każdego elementu wektora/macierzy 1
print(x * 2)      # przemnożenie każdego elementu wektora/macierzy przez 2
print(x // 2)     # dzielenie całkowite każdego elementu wektora/macierzy przez 2
print(x ** 2)     # kwadrat macierzy/wektora
print(x % 2)      # dzielenie modulo każdego elementu wektora/macierzy przez 2
print(1 / x)      # odwrotność każdego elementu wektora/macierzy

x = np.arange(-5,5)
print(x)

y = x[3:5]     # elementy wektora od pozycji 3. do 4. (indeksacja od 0)
print(y)
y[:] = 1000    # zmodyfikowanie wartości w każdym elemencie wekora y

print(y)
print(x)

# UWAGA - zmodyfikowano również wektor x !!!

x = np.arange(-5,5)
print(x)
z = x[3:5].copy()   # z jest kopią fragmentu wektora x
print(z)
z[:] = 500          # modyfikacja wartości w każdym elemencie wektora z
print(z)
print(x)

# UWAGA - po skopiowaniu fragmentu x do z nie został modyfikowany wektor x

print(x[2:4]) # wyświetlenie wektora x od pozycji o indeksie 2 do pozycji o indeksie 3
print(x[2:]) # wyświetlenie wektora x od pozycji o indeksie 2 do końca
print(x[:4]) # wyświetlenie wektora x od początku do elementu o indeksie 3
print(x[:])  # tożsme z print(x)

mat2D = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]  # macierz w postaci listy wierszy
print(mat2D)

print(mat2D[2])        # trzeci wiersz macierzy
print(mat2D[:][2])     # trzecia kolumna macierzy
print(mat2D[2][2])     # element macierzy o indeksach [2,2]

# print(mat2D[2,2])    # w przypadku listy list pojawi się błąd!

matrix2D = np.array(mat2D)
print(matrix2D)
print(matrix2D[2][:])      # trzeci wiersz macierzy
print(matrix2D[2,:])       # trzeci wiersz macierzy
print(matrix2D[:][2])      # trzeci wiersz macierzy
print(matrix2D[:,2])       # trzecia kolumna macierzy
print(matrix2D[2,2])       # element macierzy o indeksie [2,2]
print(matrix2D[2][2])      # element macierzy o indeksie [2,2]
print(matrix2D[:2,:2])     # podmacierz od elementu o indeksie 0 do 1 w wierszu i w kolumnie
print(matrix2D[ matrix2D % 2 == 0]) # elementy macierzy spełniające podany warunek logiczny
print(matrix2D[2, matrix2D[2] % 2 == 0]) # elementy macierzy spełniające podany warunek logiczny
print(matrix2D[[0,1,2,3], [0,1,2,3]]) # elementy macierzy o podanych parach indeksów [0,0], [1,1], [2,2], [3,3]

"""### Funkcje arytmetyczne i statystyczne"""

y = np.random.rand(1, 5) - 0.5   # wektor 5 losowych wartości z przedziału [-0.5, 0.5]
print(y)
print()
print(np.abs(y))                      # wartość bezwzględna
print(np.sqrt(abs(y)))                # pierwiastek
print(np.sign(y))                     # znak
print(np.exp(y))                      # e^x
print(np.sort(y))                     # posortowany wektor
print("Min =", np.min(y))             # minimalna wartość z y
print("Max =", np.max(y))             # maksymalna wartość z y
print("Avg =", np.mean(y))            # średnia wartość y
print("Std dev =", np.std(y))         # odchylenie standowe
print("Sum =", np.sum(y))             # suma elementów

x = np.random.rand(1, 5)     # wektor 5 losowych elementów z przedziału [0, 1]
print()
print(x)
print()

print(np.add(x,y))           # x + y
print(x + y)
print(np.subtract(x,y))      # x - y
print(x - y)
print(np.multiply(x,y))      # x * y
print(x * y)
print(np.divide(x,y))        # x / y
print(x /y)
print(np.maximum(x,y))       # max(x,y)

"""### Elementy algebry liniowej"""

mat = np.random.rand(4, 4)  # macierz 4x4 o losowych wartościach z przedziału [0, 1]

print(mat)
print()
print(np.linalg.inv(mat))  # macierz odwrotna
print()
print(np.transpose(mat))   # macierz transponowana
print()
print(np.linalg.det(mat))  # wyznacznik macierzy
v, w = np.linalg.eig(mat)  # v - wartości własne macierzy, w - wektory własne do wartości własnych
print(v)
print()
print(w)
print()

vec = np.random.rand(4)

print(vec)               # wektor wierszowy
print(np.transpose(vec)) # wektor kolumnowy

print()
print( mat * vec ) # macierz x wektor
print()
print( mat * np.transpose(vec)) # macierz x wektor
print()
print(np.dot(mat, vec)) # iloczyn skalarny

"""## pandas

### Szeregi
"""

from pandas import Series

s = Series( np.random.rand(5) ) # szereg z listy losowych elementów
print(s)
print("Wartości: ", s.values)
print("Indeksy: ", s.index)

s1 = Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
            index = ['styczeń', 'luty', 'marzec', 'kwiecień', 'maj', 'czerwiec', 'lipiec', 'sierpień', 'wrzesień', 'październik', 'listopad', 'grudzień'])

print(s1)

kraje = { "PL": "Polska", "GB": "Wielka Brytania", "DE": "Niemcy", "FR" : "Francja"}
s2 = Series(kraje)
print(s2)

"""### DataFrame - tabele"""

from pandas import DataFrame
pogoda = {"dzień": ["poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota", "niedziela"],
          "temperatura": [22.0, 24.0, 26.0, 24.0, 25.0, 18.0, 16.0],
          "zachmurzenie": ["pogodnie", "pogodnie", "pogodnie", "częściowe zachmurzenie", "przelotne opady", "burze", "gradobicia"]}
pogodaTab = DataFrame(pogoda)

pogodaTab

print(pogodaTab.iloc[:,0:])

pogodaTab.T

pogodaTab.T[6]

pogodaTab.T.loc['dzień']

print(pogodaTab["temperatura"]) # wybór jednej kolumny
print()
print(pogodaTab.iloc[0]) #pododa na poniedziałek
print()
print(pogodaTab.iloc[4:]) #pogoda na weekend
print()
print(pogodaTab[pogodaTab.temperatura < 24 ]) # kiedy temperatura będzie niższa niż 24*C
print()
print(pogodaTab.iloc[:, 0:2]) # tylko temperatura
print()
print(pogodaTab.T) # transpozycja tabeli
print()
print(pogodaTab[4:].temperatura + 5.0) # w weekend zdecydowanie cieplej

DataFrame(pogodaTab.iloc[:, 0:2]) # tylko temperatura jako nowy DataFrame

mat = np.random.rand(5, 5)

matTab = DataFrame(mat)
print(matTab.to_string(index=False, header=None)) # ukrycie indeksów i nagłówków

matTab.to_csv("matTab.csv", index=False, header=None)

matTab.to_csv("matTab.csv")

matTab.to_excel("matTab.xlsx")

"""### Przykład - zbiór IRIS z pliku CSV"""

df = pd.read_csv(url, header=[1])

df

df.columns = ['sepal length','sepal width','petal length','petal width','target']

df

import pandas as pd
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"
df = pd.read_csv(url, names=['sepal length','sepal width','petal length','petal width','target']) # załadowanie zbioru IRIS do DataFrame i przypisanie im odpowiednich nagłówklów tabeli

df



"""## Wykresy z wykorzystaniem Matplotlib

### Prosty wykres liniowy
"""

import matplotlib.pyplot as plt

X = np.linspace(0,10, 10)
Y = np.random.randn(10)

print(X)
print(Y)

plt.plot(X, Y, 'D--',label="dowolna wartosci X") # domyśly wykres
plt.title("Wykres liniowy")
plt.xlabel("wartości na X")
plt.ylabel("wartości na X")
plt.grid(True)
plt.legend()

plt.scatter(X, Y,label="dowolna wartosci X") # domyśly wykres
plt.title("Wykres liniowy")
plt.xlabel("wartości na X")
plt.ylabel("wartości na X")
plt.grid(True)
plt.legend()

#piechart

labels = 'A', 'B', 'C', 'D'
sizes = [15, 30, 45, 10]
explode = (0, 0.2, 0, 0.1)  # "wysunięcie" jednego z segmentów

plt.pie(sizes, explode=explode, labels=labels, autopct='%1.3f%%', shadow=True, startangle=90)
plt.axis('equal')  # równy aspect ratio, żeby koło wyglądało jak koło
plt.show()

"""### Wykres punktowy"""

plt.plot(X, Y, 'bo') # wykres punktowy

# Wykres punktowy (Scatter plot) z różnymi kolorami i rozmiarami
N = 50
x = np.random.rand(N)
y = np.random.rand(N)
colors = np.random.rand(N)
area = np.pi * (15 * np.random.rand(N))**2

plt.scatter(x, y, s=area, c=colors, alpha=1.0)
plt.show()

"""### Wykres słupkowy"""

plt.barh(X, Y)
plt.title("Wykres slupkowy")
plt.xlabel("wartości na X")
plt.ylabel("wartości na Y")
plt.grid()
plt.savefig("barplot horizontal.png")



plt.bar(X, Y)
plt.title("Wykres slupkowy")
plt.xlabel("wartości na X")
plt.ylabel("wartości na Y")
plt.grid()

"""### Histogram"""

plt.hist(Y, bins=20)

#stacked plot
A = [15, 30, 45, 10]
B = [10, 15, 20, 25]

index = np.arange(4)
plt.bar(index, A, label='A', color='b')
plt.bar(index, B, label='B', color='r', bottom=A)
plt.plot(index, A, label='A', color='k')
plt.plot(index, B, label='B', color='g')
plt.xlabel('Kategoria')
plt.ylabel('Wartość')
plt.xticks(index, ('K1', 'K2', 'K3', 'K4'))
plt.legend()
plt.show()

index = np.arange(4)
plt.plot(index, A, label='A', color='b')
plt.plot(index, B, label='B', color='r')
plt.xlabel('Kategoria')
plt.ylabel('Wartość')
plt.xticks(index, ('K1', 'K2', 'K3', 'K4'))
plt.legend()
plt.show()

# Wykres słupkowy poziomy (Horizontal bar chart)
plt.barh(index, A, color='g')
plt.ylabel('Kategoria')
plt.xlabel('Wartość')
plt.yticks(index, ('XD1', 'XD2', 'XD3', 'XD4'))
plt.show()

#wiolinowy
data = [np.random.normal(0, std, 100) for std in range(1, 5)]
plt.violinplot(data)
plt.show()

#boxplot
data = [np.random.normal(0, std, 100) for std in range(6, 10)]
plt.boxplot(data, vert=True, patch_artist=True)
plt.show()

# #  Wykres 3D
# from mpl_toolkits.mplot3d import Axes3D
# fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')
# ax.scatter(xs=x, ys=y, zs=Z, zdir='z', s=20, c='b', depthshade=True)
# plt.show()

# Wykres konturowy (Contour plot)
x = np.linspace(-3, 3, 100)
y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(X) * np.cos(Y)

plt.contour(X, Y, Z)
plt.show()

# Wykres wypełniony (Filled contour plot)
plt.contourf(X, Y, Z, 20, cmap='RdGy')
plt.colorbar()
plt.show()

"""### Wykres bezpośrednio z szeregu"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
s = Series(Y, index=X)
s.plot()

"""### Bardziej zaawansowany wykres"""

X = np.linspace(0, 100, 40)
Y = 2 * X + 3.4  # y(x) = 2x+3.4

noise = (np.random.rand(len(Y)) - 0.5) * 20  + Y

plt.plot(X, noise, "rs")
plt.plot(X, Y, color="#ffcc00", linewidth=3)
plt.grid(True)
plt.xlim(10, 90)
plt.ylim(25, 190)
plt.xlabel("X")
plt.ylabel("Y")

"""### Wykres stworzony ze zbioru IRIS"""

import pandas as pd
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"
df = pd.read_csv(url, names=['sepal length','sepal width','petal length','petal width','target']) # załadowanie zbioru IRIS do DataFrame i przypisanie im odpowiednich nagłówklów tabeli


fig = plt.figure(figsize = (8,8))
ax = fig.add_subplot(1,1,1)
ax.set_xlabel('sepal length', fontsize = 15)
ax.set_ylabel('sepal width', fontsize = 15)
ax.set_title('2 cechy zbioru IRIS', fontsize = 20)
targets = ['Iris-setosa', 'Iris-versicolor', 'Iris-virginica']
colors = ['r', 'g', 'b']
for target, color in zip(targets,colors):
    indicesToKeep = df['target'] == target
    ax.scatter(df.loc[indicesToKeep, 'sepal length']
               , df.loc[indicesToKeep, 'sepal width']
               , c = color
               , s = 50)
ax.legend(targets)
ax.grid()

#praca z excelem

# https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_spreadsheets.html#compare-with-spreadsheets

#wczytywanie plikow po numerze, mozna równiez po nazwie

employee_df = pd.read_excel('employee.xlsx')

employee_df

# df1 = pd.read_excel('E:\employee.xlsx',sheet_name=0)
# df2 = pd.read_excel('E:\employee.xlsx',sheet_name=1)
df3 = pd.read_excel('employee.xlsx',sheet_name=2)

df3 = pd.read_excel('employee.xlsx',sheet_name=2)

df3

# Tworzenie dodatkowego DataFrame'u dla demonstracji łączenia
additional_info = {
    'emp_id': [101, 102, 103, 104, 105, 106],
    'department': ['Finance', 'IT', 'IT', 'HR', 'Finance', 'HR'],
    'salary': [70000, 75000, 60000, 58000, 62000, 59000]
}

additional_df = pd.DataFrame(additional_info)

# Wyświetlenie dodatkowego DataFrame'u
additional_df

# # Przygotowanie wyników dla różnych typów join/merge

# # Inner Join
inner_join_result = pd.merge(employee_df, additional_df, on='emp_id', how='inner')

# # Left Join
left_join_result = pd.merge(employee_df, additional_df, on='emp_id', how='left')

# # Right Join
right_join_result = pd.merge(employee_df, additional_df, on='emp_id', how='right')

# # Outer Join
outer_join_result = pd.merge(employee_df, additional_df, on='emp_id', how='outer')

# # Wyświetlenie wyników
# (inner_join_result, left_join_result, right_join_result, outer_join_result)



inner_join_result

left_join_result

outer_join_result

employee_df.sort_values(by=['last_name','first_name'] , ascending=False)

# employee_df['hire_date'] = pd.datetime(employee_df['hire_date'])

employee_df['first_name'].apply(len).sort_values().index

employee_df.info()

sort_by_first_name_length = employee_df.iloc[employee_df['first_name'].apply(len).sort_values().index]

employee_df.loc[(employee_df['first_name'].apply(len)+employee_df['last_name'].apply(len)).sort_values().index]



# # Wykonanie kilku przykładowych sortowań

# # Przykład 1: Sortowanie według last_name
# sort_by_last_name = employee_df.sort_values(by='last_name')

# # Przykład 2: Sortowanie według hire_date w porządku malejącym
# sort_by_hire_date_desc = employee_df.sort_values(by='hire_date', ascending=False)

# # Przykład 5: Sortowanie według długości first_name
# sort_by_first_name_length = employee_df.loc[employee_df['first_name'].apply(len).sort_values().index]

pd.to_datetime('2005-01-01',format='%Y-%m-%d %H:%M:%S.%f')

pd.to_datetime('2005-01-01',format='%Y-%m-%d').month

employee_df[employee_df['hire_date'] > pd.to_datetime('2005-01-01')]

employee_df[employee_df['emp_id'] <= 105]

employee_df[employee_df['first_name'].isin(['Bruce', 'David','Steven','Neena'])]

employee_df[~employee_df['last_name'].isin(['King'])]

employee_df[employee_df['last_name'].str.contains('ch')]

employee_df[employee_df['first_name'].str.startswith('L')]

employee_df[(employee_df['emp_id'] > 100) & (employee_df['hire_date'] < pd.to_datetime('2006-01-01'))]

# #filtrowanie


#Przykład 1: Filtrowanie według pojedynczej wartości w kolumnie
# Wybierz pracowników, których `first_name` to 'Bruce'.

#
# employee_df[employee_df['first_name'] == 'Bruce']
#

#Przykład 2: Filtrowanie z użyciem operatora `>`
# Wybierz pracowników, którzy zostali zatrudnieni po 2005 roku.

#
# employee_df[employee_df['hire_date'] > '2005-01-01']
#

#Przykład 3: Filtrowanie z użyciem operatora `<=`
# Wybierz pracowników, których `emp_id` jest mniejsze lub równe 105.

#
# employee_df[employee_df['emp_id'] <= 105]
#

#Przykład 4: Filtrowanie z użyciem `isin`
# Wybierz pracowników, których imiona znajdują się na liście ['Bruce', 'David'].

#
# employee_df[employee_df['first_name'].isin(['Bruce', 'David'])]
#

#Przykład 5: Filtrowanie z użyciem negacji `~`
# Wybierz pracowników, których nazwisko nie jest 'King'.

#
# employee_df[~employee_df['last_name'].isin(['King'])]
#

#Przykład 6: Filtrowanie z użyciem `str.contains`
# Wybierz pracowników, których nazwisko zawiera ciąg 'en'.

#
# employee_df[employee_df['last_name'].str.contains('en')]
#

#Przykład 7: Filtrowanie z użyciem `str.startswith`
# Wybierz pracowników, których imię zaczyna się od 'L'.

#
# employee_df[employee_df['first_name'].str.startswith('L')]
#

#Przykład 8: Filtrowanie z użyciem `str.endswith`
# Wybierz pracowników, których imię kończy się na 's'.

#
# employee_df[employee_df['first_name'].str.endswith('s')]
#

#Przykład 9: Filtrowanie złożone z użyciem `&` (AND)
# Wybierz pracowników, których `emp_id` jest większe niż 100 i którzy zostali zatrudnieni przed 2006 rokiem.

#
# employee_df[(employee_df['emp_id'] > 100) & (employee_df['hire_date'] < '2006-01-01')]
#

#Przykład 10: Filtrowanie złożone z użyciem `|` (OR)
# Wybierz pracowników, których imię to 'Bruce' lub którzy zostali zatrudnieni po 2006 roku.

#
# employee_df[(employee_df['first_name'] == 'Bruce') | (employee_df['hire_date'] > '2006-01-01')]
#

#query

filtered_query_single = employee_df.query('emp_id > 105')

filtered_query_single

filtered_query_multiple = employee_df.query('emp_id < 115 & hire_date > "2003-01-01"')
filtered_query_multiple

# # Przykład 1: Filtrowanie z użyciem query dla pojedynczego warunku
# filtered_query_single = employee_df.query('emp_id > 105')

# # Przykład 2: Filtrowanie z użyciem query dla wielu warunków
# filtered_query_multiple = employee_df.query('emp_id < 115 & hire_date > "2003-01-01"')

# # Przykład 3: Filtrowanie z użyciem isin z negacją
# filtered_isin_negation = employee_df[~employee_df['first_name'].isin(['Alexander', 'Bruce'])]

# # Przykład 4: Filtrowanie pracowników, których hire_date jest w określonym zakresie
# filtered_date_range = employee_df[(employee_df['hire_date'] >= '2003-01-01') & (employee_df['hire_date'] <= '2005-12-31')]

# # Przykład 5: Filtrowanie z użyciem funkcji lambda na kolumnie
# filtered_lambda = employee_df[employee_df['last_name'].apply(lambda x: len(x) > 5)]

# (filtered_query_single, filtered_query_multiple, filtered_isin_negation, filtered_date_range, filtered_lambda)

plt.figure(figsize=(10, 6))
sns.countplot(y='hire_year', data=employee_df)
plt.title('Liczba pracowników zatrudnionych w każdym roku')
plt.show()

plt.figure(figsize=(10, 6))
sns.barplot(x='hire_year', y='emp_id', data=employee_df, estimator=lambda x: len(x))
plt.title('Średni emp_id dla pracowników zatrudnionych w każdym roku')
plt.show()

employee_df['first_name_length'] = employee_df['first_name'].apply(len)
plt.figure(figsize=(10, 6))
sns.histplot(employee_df['first_name_length'], bins=10, kde=False)
plt.title('Rozkład liczby znaków w first_name')
plt.show()

plt.figure(figsize=(10, 6))
sns.violinplot(x='hire_year', y='first_name_length', data=employee_df)
plt.title('Rozkład długości first_name z podziałem na lata zatrudnienia')
plt.show()

plt.figure(figsize=(10, 6))
sns.swarmplot(x='hire_year', y='first_name_length', data=employee_df)
plt.title('Rozkład długości first_name w zależności od roku zatrudnienia')
plt.show()

# Utworzenie dodatkowego DataFrame'u dla Pairplot (wymaga numerycznych danych)
sns.pairplot(employee_df[['emp_id', 'first_name_length', 'hire_year']])
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# # Dodanie kolumny z rokiem zatrudnienia dla celów demonstracyjnych
employee_df['hire_year'] = employee_df['hire_date'].dt.year

# # 1. Countplot
plt.figure(figsize=(10, 6))
sns.countplot(x='hire_year', data=employee_df)
plt.title('Liczba pracowników zatrudnionych w każdym roku')
plt.show()

# # 2. Barplot
# plt.figure(figsize=(10, 6))
# sns.barplot(x='hire_year', y='emp_id', data=employee_df, estimator=lambda x: len(x))
# plt.title('Średni emp_id dla pracowników zatrudnionych w każdym roku')
# plt.show()

# # 3. Histogram
# employee_df['first_name_length'] = employee_df['first_name'].apply(len)
# plt.figure(figsize=(10, 6))
# sns.histplot(employee_df['first_name_length'], bins=10, kde=False)
# plt.title('Rozkład liczby znaków w first_name')
# plt.show()

# # 4. Boxplot
# plt.figure(figsize=(10, 6))
# sns.boxplot(x='hire_year', y='first_name_length', data=employee_df)
# plt.title('Rozkład długości first_name pracowników')
# plt.show()

# # 5. Violinplot
# plt.figure(figsize=(10, 6))
# sns.violinplot(x='hire_year', y='first_name_length', data=employee_df)
# plt.title('Rozkład długości first_name z podziałem na lata zatrudnienia')
# plt.show()

# # 6. Stripplot
# plt.figure(figsize=(10, 6))
# sns.stripplot(x='hire_year', y='emp_id', data=employee_df)
# plt.title('Rozkład emp_id w zależności od roku zatrudnienia')
# plt.show()

# # 7. Swarmplot
# plt.figure(figsize=(10, 6))
# sns.swarmplot(x='hire_year', y='first_name_length', data=employee_df)
# plt.title('Rozkład długości first_name w zależności od roku zatrudnienia')
# plt.show()

# # 8. Lineplot
# plt.figure(figsize=(10, 6))
# sns.lineplot(x='hire_year', y='emp_id', data=employee_df)
# plt.title('Trend zatrudniania pracowników w czasie')
# plt.show()

# # 9. Scatterplot
# plt.figure(figsize=(10, 6))
# sns.scatterplot(x='emp_id', y='first_name_length', data=employee_df)
# plt.title('Zależność między emp_id a długością first_name')
# plt.show()

# # 10. Pairplot
# # Utworzenie dodatkowego DataFrame'u dla Pairplot (wymaga numerycznych danych)
# sns.pairplot(employee_df[['emp_id', 'first_name_length', 'hire_year']])
# plt.show()

np.random.seed(0)
employee_df['salary'] = np.random.randint(50000, 120000, len(employee_df))

# 11. Heatmap
# Przykładowa korelacja dla ilustracji
corr = employee_df[['emp_id', 'first_name_length', 'salary']].corr()
plt.figure(figsize=(10, 6))
sns.heatmap(corr, annot=True, fmt=".4f")
plt.title('Heatmapa korelacji między emp_id, first_name_length i salary')
plt.show()

# 12. FacetGrid
g = sns.FacetGrid(employee_df, col="hire_year", col_wrap=4, height=3)
g = g.map(plt.hist, "salary")
plt.show()

# 13. PairGrid
g = sns.PairGrid(employee_df[['emp_id', 'first_name_length', 'salary']])
g.map_upper(sns.scatterplot)
g.map_lower(sns.kdeplot)
g.map_diag(sns.histplot)
plt.show()

# 14. Jointplot
sns.jointplot(x='first_name_length', y='salary', data=employee_df, kind='scatter')
plt.show()

plt.figure(figsize=(10, 6))
sns.kdeplot(employee_df['first_name_length'])
plt.title('Estymacja gęstości jądrowej dla długości first_name')
plt.show()

# 17. Rugplot
plt.figure(figsize=(10, 6))
sns.rugplot(employee_df['salary'])
plt.title('Rugplot dla salary')
plt.show()

# # Przygotowanie danych dla dodatkowych wykresów
# # Zakładam, że mamy dodatkową kolumnę 'salary' dla tych przykładów
# np.random.seed(0)
# employee_df['salary'] = np.random.randint(50000, 120000, len(employee_df))

# # 11. Heatmap
# # Przykładowa korelacja dla ilustracji
# corr = employee_df[['emp_id', 'first_name_length', 'salary']].corr()
# plt.figure(figsize=(10, 6))
# sns.heatmap(corr, annot=True, fmt=".2f")
# plt.title('Heatmapa korelacji między emp_id, first_name_length i salary')
# plt.show()

# # 12. FacetGrid
# g = sns.FacetGrid(employee_df, col="hire_year", col_wrap=4, height=3)
# g = g.map(plt.hist, "salary")
# plt.show()

# # 13. PairGrid
# g = sns.PairGrid(employee_df[['emp_id', 'first_name_length', 'salary']])
# g.map_upper(sns.scatterplot)
# g.map_lower(sns.kdeplot)
# g.map_diag(sns.histplot)
# plt.show()

# # 14. Jointplot
# sns.jointplot(x='first_name_length', y='salary', data=employee_df, kind='scatter')
# plt.show()

# # 15. Kdeplot
# plt.figure(figsize=(10, 6))
# sns.kdeplot(employee_df['first_name_length'])
# plt.title('Estymacja gęstości jądrowej dla długości first_name')
# plt.show()

# # 16. Distplot
# plt.figure(figsize=(10, 6))
# sns.histplot(employee_df['salary'], kde=True)
# plt.title('Rozkład salary z histogramem i krzywą gęstości')
# plt.show()

# # 17. Rugplot
# plt.figure(figsize=(10, 6))
# sns.rugplot(employee_df['salary'])
# plt.title('Rugplot dla salary')
# plt.show()

# # 18. Pointplot
# plt.figure(figsize=(10, 6))
# sns.pointplot(x='hire_year', y='salary', data=employee_df)
# plt.title('Średnia salary dla różnych lat zatrudnienia')
# plt.show()

# # 19. Lmplot
# sns.lmplot(x='first_name_length', y='salary', data=employee_df)
# plt.title('Regresja liniowa między długością first_name a salary')
# plt.show()

# # 20. Clustermap
# sns.clustermap(employee_df[['emp_id', 'first_name_length', 'salary']].corr(), annot=True)
# plt.show()

employee_df

pivot1 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=np.sum)
print(pivot1)

# employee_df.groupby('hire_year').sum()

pivot2 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=[np.mean, np.sum, np.max])
print(pivot2)

# employee_df

pivot3 = pd.pivot_table(employee_df, values='salary', index=['hire_year', 'hire_date'], aggfunc=np.mean)
print(pivot3)

# Tabela przestawna z wieloma wartościami
pivot6 = pd.pivot_table(employee_df, values=['salary', 'emp_id'], index='hire_year', aggfunc={'salary': np.mean, 'emp_id': len})
print(pivot6)

pivot7 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=np.sum, margins=True, margins_name='Total')
print(pivot7)

pivot9 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=lambda x: np.percentile(x, 0.10))
print(pivot9)

# Filtr danych przed tworzeniem tabeli przestawnej
filtered_data = employee_df[employee_df['salary'] > 10000]
pivot10 = pd.pivot_table(filtered_data, values='salary', index='hire_year', aggfunc=np.mean)
print(pivot10)

#Przykład 1: Podstawowa tabela przestawna

#
# # Podstawowa tabela przestawna, sumująca salary w zależności od hire_year
# pivot1 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=np.sum)
# print(pivot1)
#

#Przykład 2: Tabela przestawna z wieloma funkcjami agregacji


# # Użycie wielu funkcji agregacji dla salary
# pivot2 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=[np.mean, np.sum, np.max])
# print(pivot2)


#Przykład 3: Tabela przestawna z wieloma indeksami

#
# # Tabela przestawna z wieloma indeksami
# pivot3 = pd.pivot_table(employee_df, values='salary', index=['hire_year', 'department'], aggfunc=np.mean)
# print(pivot3)
#

#Przykład 4: Tabela przestawna z kolumnami

#
# # Dodanie kolumn do tabeli przestawnej
# pivot4 = pd.pivot_table(employee_df, values='salary', index='hire_year', columns='department', aggfunc=np.mean)
# print(pivot4)
#

#Przykład 5: Wypełnianie wartości brakujących

#
# # Wypełnianie wartości brakujących w tabeli przestawnej
# pivot5 = pd.pivot_table(employee_df, values='salary', index='hire_year', columns='department', aggfunc=np.mean, fill_value=0)
# print(pivot5)
#

#Przykład 6: Tabela przestawna z wieloma wartościami

#
# # Tabela przestawna z wieloma wartościami
# pivot6 = pd.pivot_table(employee_df, values=['salary', 'emp_id'], index='hire_year', aggfunc={'salary': np.mean, 'emp_id': len})
# print(pivot6)
#

#Przykład 7: Obliczanie totali

#
# # Dodawanie totali do tabeli przestawnej
# pivot7 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=np.sum, margins=True, margins_name='Total')
# print(pivot7)
#

#Przykład 8: Sortowanie danych w tabeli przestawnej

#
# # Sortowanie danych w tabeli przestawnej
# pivot8 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=np.sum).sort_values(by='salary', ascending=False)
# print(pivot8)
#

#Przykład 9: Tabela przestawna z użyciem `lambda`

#
# # Użycie funkcji lambda w aggfunc
# pivot9 = pd.pivot_table(employee_df, values='salary', index='hire_year', aggfunc=lambda x: np.quantile(x, 0.75))
# print(pivot9)
#

#Przykład 10: Tabela przestawna z filtrowaniem danych

#
# # Filtr danych przed tworzeniem tabeli przestawnej
# filtered_data = employee_df[employee_df['salary'] > 60000]
# pivot10 = pd.pivot_table(filtered_data, values='salary', index='hire_year', aggfunc=np.mean)
# print(pivot10)
#

# Każdy z tych przykładów ilustruje różne sposoby wykorzystania tabel przestawnych w Pandas do podsumowywania i analizy danych. Możesz dostosować te przykłady do swoich danych, aby uzyskać potrzebne informacje.

"""### Różnice między `map`, `applymap`, `apply`:

- **`map`** jest metodą stosowaną na `Series`, która stosuje określoną funkcję do każdego elementu w serii. Może być używana do zastępowania wartości w kolumnie przy użyciu słownika, serii lub funkcji.

- **`applymap`** działa na każdym pojedynczym elemencie DataFrame'u. Jest to metoda DataFrame, a nie Series, i jest używana głównie do elementów transformujących operacje.

- **`apply`** działa na całej osi DataFrame'u, co oznacza, że można ją stosować zarówno do wierszy, jak i kolumn. Jest bardziej ogólna i potężna w porównaniu z `map` i `applymap`.

### Przykłady użycia `map`, `applymap`, `apply`, `lambda`:

#### Przykłady z użyciem `map`:

1. **Zmiana imienia na inny format**:
   ```python
   employee_df['first_name'] = employee_df['first_name'].map(lambda x: x.lower())
   ```

2. **Zamiana imion z użyciem słownika**:
   ```python
   name_map = {'alexander': 'Alex', 'bruce': 'Bruce'}
   employee_df['first_name'] = employee_df['first_name'].map(name_map).fillna(employee_df['first_name'])
   ```

#### Przykłady z użyciem `applymap`:

3. **Zamiana wszystkich ciągów na małe litery w całym DataFrame**:
   ```python
   employee_df = employee_df.applymap(lambda x: x.lower() if type(x) is str else x)
   ```

4. **Zwiększenie każdego elementu numerycznego o jeden**:
   ```python
   employee_df = employee_df.applymap(lambda x: x + 1 if type(x) is int else x)
   ```

#### Przykłady z użyciem `apply`:

5. **Dodanie prefiksu do imion**:
   ```python
   employee_df['first_name'] = employee_df['first_name'].apply(lambda x: f"Mr. {x}")
   ```

6. **Obliczenie długości każdego imienia**:
   ```python
   employee_df['name_length'] = employee_df['first_name'].apply(len)
   ```

7. **Tworzenie nowej kolumny z połączonych danych imienia i nazwiska**:
   ```python
   employee_df['full_name'] = employee_df.apply(lambda row: f"{row['first_name']} {row['last_name']}", axis=1)
   ```

8. **Zmiana formatu daty zatrudnienia**:
   ```python
   employee_df['hire_date'] = employee_df['hire_date'].apply(lambda x: x.strftime('%Y-%m-%d'))
   ```

9. **Kategoryzacja na podstawie `emp_id`**:
   ```python
   employee_df['category'] = employee_df['emp_id'].apply(lambda x: 'Category 1' if x > 200 else 'Category 2')
   ```

10. **Normalizacja wartości `emp_id`** (przy założeniu, że `emp_id` jest numeryczny):
    ```python
    employee_df['emp_id_normalized'] = employee_df['emp_id'].apply(lambda x: (x - employee_df['emp_id'].min()) / (employee_df['emp_id'].max() - employee_df['emp_id'].min()))
    ```
"""

employee_df['first_name']

employee_df['first_name'].map(lambda x: x.upper())

name_map = {'Alexander': 'Alex', 'bruce': 'Bruce'}
employee_df['first_name'] = employee_df['first_name'].map(name_map).fillna(employee_df['first_name'])

employee_df.applymap(lambda x: x.upper() if type(x) is str else x)

employee_df.applymap(lambda x: x + 1 if type(x) is int else x)

employee_df['hire_date'].apply(lambda x: x.strftime('%Y'))

employee_df['emp_id'].apply(lambda x: 'Category 1' if x > 200 else 'Category 2')

employee_df['emp_id'].apply(lambda x: (x - employee_df['emp_id'].min()) / (employee_df['emp_id'].max() - employee_df['emp_id'].min()))